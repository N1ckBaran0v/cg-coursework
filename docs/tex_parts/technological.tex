\chapter{Технологическая часть}

\section{Средства реализации}

Для реализации данной лабораторной работы был выбран язык C++, так как он содержит необходимые средства для реализации алгоритмов. Также программы на этом языке могут быть запущены на микроконтроллере stm32, что является необходимым условием для выполнения лабораторной работы. 

\section{Реализация алгоритмов}

В листингах \ref{lst:levRec}, \ref{lst:levItr}, \ref{lst:levMem}, \ref{lst:damItr}  представлены реализации алгоритмов нахождения расстояний Левенштейна и Дамерау-Левенштейна.

\begin{lstlisting}[label=lst:levRec,caption=Метод рекурсивного нахождения расстояния Левенштейна]
int LevenshteinRecursiveAlgorithm::execute() {
	return count(first.size(), second.size());
}

int LevenshteinRecursiveAlgorithm::count(const int s1, const int s2) {
	auto result = s1 + s2;
	if (s1 > 0 && s2 > 0) {
		result = std::min({count(s1 - 1, s2) + 1, count(s1, s2 - 1) + 1, 
			count(s1 - 1, s2 - 1) + (first[s1 - 1] != second[s2 - 1])});
	}
	return result;
}
\end{lstlisting}

\begin{lstlisting}[label=lst:levMem,caption=Метод рекурсивного нахождения расстояния Левенштейна с мемоизацией]
int LevenshteinMemoisedAlgorithm::execute() {
	cache = initMatrix(first.size() + 1, second.size() + 1);
	auto result = count(first.size(), second.size());
	if (isNeedPrintMatrix()) {
		printMatrix(cache);
	} 
	return result;
}

int LevenshteinMemoisedAlgorithm::count(const int s1, const int s2) {
	if (cache[s1][s2] == -1) {
		cache[s1][s2] = s1 + s2;
		if (s1 > 0 && s2 > 0) {
			cache[s1][s2] = std::min({count(s1 - 1, s2) + 1, count(s1, s2 - 1) + 1, 
				count(s1 - 1, s2 - 1) + (first[s1 - 1] != second[s2 - 1])});
		}
	}
	return cache[s1][s2];
}
\end{lstlisting}

\begin{lstlisting}[label=lst:levItr,caption=Метод матричного нахождения расстояния Левенштейна]
	int LevenshteinTableAlgorithm::execute() {
		auto s1 = first.size() + 1;
		auto s2 = second.size() + 1;
		table = initMatrix(s1, s2);
		for (auto i = 0; i < s1; ++i) {
			for (auto j = 0; j < s2; ++j) {
				table[i][j] = i + j;
				if (i > 0 && j > 0) {
					table[i][j] = std::min({table[i - 1][j] + 1, table[i][j - 1] + 1, 
						table[i - 1][j - 1] + (first[i - 1] != second[j - 1])});
				}
			}
		}
		if (isNeedPrintMatrix()) {
			printMatrix(table);
		} 
		return table[first.size()][second.size()];
	}
\end{lstlisting}

\begin{lstlisting}[label=lst:damItr,caption=Метод матричного нахождения расстояния Дамерау-Левенштейна]
int DamerauLevenshteinAlgorithm::execute() {
	auto s1 = first.size() + 1;
	auto s2 = second.size() + 1;
	table = initMatrix(s1, s2);
	for (auto i = 0; i < s1; ++i) {
		for (auto j = 0; j < s2; ++j) {
			table[i][j] = i + j;
			if (i > 0 && j > 0) {
				table[i][j] = std::min({table[i - 1][j] + 1, table[i][j - 1] + 1, 
					table[i - 1][j - 1] + (first[i - 1] != second[j - 1])});
				if (i > 1 && j > 1 && first[i - 1] == second[j - 2] && first[i - 2] == second[j - 1]) {
					table[i][j] = std::min(table[i][j], table[i - 2][j - 2] + 1);
				}
			}
		}
	}
	if (isNeedPrintMatrix()) {
		printMatrix(table);
	} 
	return table[first.size()][second.size()];
}
\end{lstlisting}

\section{Функциональные тесты}

В таблице \ref{tab} представлены функциональные тесты и результаты их выполнения. 4 числа в результатах означают возвращаемые значения всех 4 реализаций алгоритмов (порядок результатов совпадает с порядком описания реализаций в листингах ).

\begin{table}[t!]
	\small
	\caption{\label{tab}Результаты выполнения функциональных тестов}
	\begin{center}
		\begin{tabular}{|c|c|c|c|c|c|}
			\hline
			№  & first & second & \makecell{Ожидаемый\\результат} & \makecell{Полученный\\результат}  &  Описание теста\\  
			\hline
			1 & & & 0 0 0 0 & 0 0 0 0 & Пустой ввод\\
			\hline
			2& Слово & Слово & 0 0 0 0 & 0 0 0 0 & Одинаковые слова\\
			\hline
			3 & один & семь & 4 4 4 4 & 4 4 4 4 & \makecell{Слова, не имеющие\\ни одной одинаковой\\буквы}\\
			\hline
			4 & бобер & ребро & 4 4 4 4 & 4 4 4 4 & \makecell{Слова, имеющие одинаковые\\расстояния Левенштейна\\и Дамерау-Левенштейна}\\
			\hline
			5 & лоск & локс & 2 2 2 1 & 2 2 2 1 & \makecell{Слова, имеющие различные\\расстояния Левенштейна\\и Дамерау-Левенштейна}\\
			\hline
			6 & белка & лак & 4 4 4 3 & 4 4 4 3 & \makecell{Первое слово длиннее второго}\\
			\hline
			7 & лак & белка & 4 4 4 3 & 4 4 4 3 & \makecell{Второе слово длиннее первого}\\
			\hline
		\end{tabular}
	\end{center}
\end{table}

\section{Вывод}

В данном разделе был выбран язык программирования для написания программы, были рализованы все ранее описанные алгоритмы, а также были описаны тесты с ожидаемым и полученным результатом.