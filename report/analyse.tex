\chapter{Аналитическая часть}

В данном разделе приведено описание объектов сцены, а также анализ существующих алгоритмов для решения поставленных задач, в результате которого выбраны наиболее подходящие из них.

\section{Формализация задачи с учётом выбранных алгоритмов}

На рисунке~\ref{img:without} представлена формализованная задача.

\FloatBarrier
\includeimage
{without} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Формализованная задача} % Подпись рисунка
\FloatBarrier

\section{Анализ объектов сцены}

Сцена состоит из следующих объектов:

\begin{enumerate}[label=\arabic*.]
	\item Источник света, расположенный на бесконечности -- задаётся 2 углами.
	\item Камера -- задаётся положением в пространстве, фокусным расстоянием, дальностью видимости, а также 3 векторами, задающими систему координат камеры.
	\item Ландшафт -- задаётся регулярной картой высот, так как параметрами генерации являются значения высот в точках и шаг задания точек, и множеством полигонов.
\end{enumerate}

\section{Анализ алгоритмов генерации ландшафта}

Существуют следующие алгоритмы генерации ландшафта~\cite{landscapes}\cite{noises}\cite{nohabrinsource}\cite{usages}\cite{Voronezh}\cite{criging}:

\begin{enumerate}[label=\arabic*.]
	\item Шум Перлина.
	\item Шум Симплекс.
	\item Дробный шум Брауна.
	\item Шум Value Noise.
	\item Fault алгоритм.
	\item Холмовой алгоритм.
	\item Алгоритм diamond-square.
	\item Алгоритм, использующий билинейную интерполяцию.
	\item Алгоритм, использующий кригинг.
\end{enumerate}

\subsection{Алгоритмы, основанные на шумовых функциях}

Алгоритмы, основанные на шумовых функциях, заполняют значения на карте высот результатами работы шумовых функций~\cite{noises}. Однако шумовые функции никак не учитывают заранее заданные на ландшафте значения высот, поэтому не подходят для генерации ландшафта.

\subsection{Fault алгоритм}

Fault алгоритм заключается в выполнении следующих шагов в несколько итераций~\cite{nohabrinsource}:

\begin{enumerate}[label=\arabic*.]
	\item плоскость делится прямой на 2 части;
	\item значения высот в одной части повышаются, а в другой -- понижаются.
\end{enumerate}

Данный алгоритм не подходит для генерации ландшафта с заранее заданными значениями высот.

\subsection{Холмовой алгоритм}

Холмовой алгоритм заключается в создании холмов на определённой области~\cite{usages}. При этом он не предусматривает наличие заранее заданных значений высот, из-за чего не подходит для генерации ландшафта.

\subsection{Алгоритм diamond-square}

Алгоритм diamond-square представляет собой расширенную версию алгоритма midpoint displacement, заключающуюся в использовании двумерной плоскости и наличии 2 этапов~\cite{ds}:

\begin{enumerate}[label=\arabic*.]
	\item этап <<square>> -- рассматриваются квадраты, для них определяются центральные точки, в которых считается среднее значение из крайних точек и добавляется случайное смещение;
	\item этап <<diamond>> -- рассматриваются ромбы, для них также определяются центральные точки, в которых считается среднее значение из крайних точек и добавляется случайное смещение. Крайние случаи необходимо рассматривать отдельно, так как часть вершин может отсутствовать.
\end{enumerate}

На выходе у него получается регулярная карта высот. Таким образом, выходит, что вся плоскость покрыта квадратами. Порядок генерации точек можно увидеть на рисунке~\ref{img:ds}. 

\FloatBarrier
\includeimage
{ds} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{0.5\textwidth} % Ширина рисунка
{Порядок генерации высот в алгоритме diamond-square~\cite{images}} % Подпись рисунка
\FloatBarrier

Данный алгоритм хорошо подходит для генерации гор~\cite{landscapes}. При этом у данного алгоритма есть сложности с генерацией значений на границах квадрата, так как на шаге square не хватает одной точки. Также сторона квадрата должна иметь размер $2^n+1$.   
 
\subsection{Алгоритм, использующий билинейную интерполяцию}
 
Алгоритм заключается в заполнении значений на карте высот результатом работы функции билинейной интерполяции $f(x, y)$~\cite{Voronezh}. Значение $f(x, y)$ рассчитывается по формуле~\ref{eq:fxy}, где $f_1(x,y)$ рассчитывается по формуле~\ref{eq:f1}, а $f_2(x,y)$ -- по формуле~\ref{eq:f2}, причём точка $(x, y)$ находится внутри прямоугольника с вершинами в точках $(x_1, y_1)$, $(x_2, y_1)$, $(x_1, y_2)$, $(x_2, y_2)$, значения в которых равны $h_{11}$, $h_{21}$, $h_{12}$ и $h_{22}$ соответственно. 

\begin{equation}
	\label{eq:fxy}
	f(x,y)=f_1(x,y)+f_2(x,y)
\end{equation}

\begin{equation}
	\label{eq:f1}
	f_1(x,y)=\frac{h_{11}\cdot(x_2-x)\cdot(y_2-y)}{(x_2-x_1)\cdot(y_2-y_1)}+\frac{h_{21}\cdot(x-x_1)\cdot(y_2-y)}{(x_2-x_1)\cdot(y_2-y_1)}
\end{equation}

\begin{equation}
	\label{eq:f2}
	f_2(x,y)=\frac{h_{12}\cdot(x_2-x)\cdot(y-y_1)}{(x_2-x_1)\cdot(y_2-y_1)}+\frac{h_{22}\cdot(x-x_1)\cdot(y-y_1)}{(x_2-x_1)\cdot(y_2-y_1)}
\end{equation}

\subsection{Алгоритм, использующий кригинг}

Цель кригинга – найти такую модель данных, среднее квадратичное значение ошибки которой будет минимальным~\cite{criging}. Оценка значения в точке~$x_0$ $z_k(x_0)$ рассчитывается по формуле~\ref{eq:zx}. В ней $n$ - число точек, от которых зависит значение в точке~$x_0$, $z(x_i)$ -- значения в этих точках, а $\lambda_i$ -- вес значения.

\begin{equation}
	\label{eq:zx}
	z_k(x_0) = \sum_{i=1}^{n}\lambda_i \cdot z(x_i)
\end{equation}

Алгоритм состоит из следующих шагов:

\begin{enumerate}[label=\arabic*.]
	\item Составляется ковариационная матрица $C$ расстояний между всеми известными точками. Значение в строке $i$ столбца $j$ $C_{ij}$ рассчитывается по формуле~\ref{eq:cov}. В ней $h$ -- расстояние между точками $i$ и $j$, $a$ -- радиус вариограммы.
	
\begin{equation}
	\label{eq:cov}
	C_{ij} = Cov(h) = 1 - \exp^{-\frac{h^2}{a^2}}
\end{equation}
	
	\item Для каждой точки $x_0$ решаем систему уравнений~\ref{eq:linal}, после чего вычисляем значение по формуле~\ref{eq:zx}.
	
\begin{equation}
	\label{eq:linal}
	\begin{cases}
		\lambda_1 \cdot C_{11} + \lambda_2 \cdot C_{12} + \ldots + \lambda_n \cdot C_{1n} - C_{10} = 0\\
		\lambda_1 \cdot C_{21} + \lambda_2 \cdot C_{22} + \ldots + \lambda_n \cdot C_{2n} - C_{20} = 0\\
		\ldots\\
		\lambda_1 \cdot C_{n1} + \lambda_2 \cdot C_{n2} + \ldots + \lambda_n \cdot C_{nn} - C_{n0} = 0\\
	\end{cases}
\end{equation}

\end{enumerate}

\subsection{Сравнение алгоритмов}

Из всех рассмотренных алгоритмов только алгоритм diamond-square, алгоритм, использующий билинейную интерполяцию, а также алгорит, использующий кригинг, подходят для генерации ландшафта с изначально заданными точками. В таблице~\ref{tab:gen} представлено сравнение всех подходящих алгоритмов генерации ландшафта.

\begin{longtable}{|p{.25\textwidth - 2\tabcolsep}|p{.25\textwidth - 2\tabcolsep}|p{.25\textwidth - 2\tabcolsep}|p{.25\textwidth - 2\tabcolsep}|}
	\caption{\label{tab:gen}Сравнение алгоритмов генерации ландшафта} \\
	\hline
	\makecell{Критерий\\сравнения} & \makecell{Алгоритм\\diamond-square} & \makecell{Алгоритм,\\использующий\\билинейную\\интерполяцию} & \makecell{Алгоритм,\\использующий\\кригинг}\\  
	\hline
	\makecell{Нужен\\генератор\\случайных\\чисел} & \makecell{Да} & \makecell{Нет} & \makecell{Нет} \\  
	\hline
	\makecell{Проблемы\\с генерацией\\значений\\на границах} & \makecell{Да} & \makecell{Нет} & \makecell{Нет} \\  
	\hline
	\makecell{Значение\\может зависеть\\от всех точек} & \makecell{Не все} & \makecell{Нет} & \makecell{Да} \\  
	\hline
\end{longtable}

В результате сравнения был выбран алгоритм, использующий кригинг, так как ему не нужны дополнительные параметры генерации, а также при генерации значения в одной точке он может учесть все заданные значения высот.

\section{Анализ алгоритмов удаления невидимых линий и поверхностей}

Для получения изображения необходимо решить задачу удаления невидимых линий и поверхностей, а также выбрать метод закраски полигонов. Существуют следующие алгоритмы удаления невидимых линий и поверхностей~\cite{parshina}\cite{golovnin}\cite{cannon}:

\begin{enumerate}[label=\arabic*.]
	\item Алгоритм Робертса.
	\item Алгоритм плавающего горизонта.
	\item Алгоритм Варнока.
	\item Алгоритм Вейлера-Азертона.
	\item Алгоритм, использующий Z-буфер.
	\item Алгоритм, использующий список приоритетов.
	\item Алгоритм обратной трассировки лучей.
\end{enumerate}

\subsection{Алгоритм Робертса}

Данный алгоритм работает в объектном пространстве~\cite{lost}. Алгоритм состоит из следующих шагов: 

\begin{enumerate}[label=\arabic*.]
	\item Удаление нелицевых граней, экранируемых самим телом.
	\item Удаление рёбер, экранируемых другими телами.
	\item Вычисление новых рёбер, полученных при <<протыкании>> друг друга.
\end{enumerate}

Время работы алгоритма $O(N^2)$, где $N$ -- число рёбер.

Ландшафт не является выпуклым телом, поэтому для данного алгоритма его придётся изначально разделить на выпуклые тела.

\subsection{Алгоритм плавающего горизонта}

Алгоритм плавающего горизонта используется при представлении поверхности в виде функции $F(x,y,z)=0$~\cite{golovnin}. Алгоритм состоит из следующих шагов:

\begin{enumerate}[label=\arabic*.]
	\item Поверхность пересекается параллельными плоскостями с постоянной координатой z (ось y направлена вверх).
	\item Для каждой такой плоскости, начиная с ближайшей, строится кривая, лежащая на ней. Если же при заданном значении x значение y больше других найденных, то кривая видима в этой точке.
\end{enumerate}

\subsection{Алгоритм Варнока}

Алгоритм Варнока состоит из следующих шагов~\cite{cannon}:

\begin{enumerate}[label=\arabic*.]
	\item \label{step:varnok1}Рассматривается окно и решается вопрос о том, пусто ли оно
	или является его содержимое достаточно простым для визуализации.
	\item Если это не так, то окно разбивается на фрагменты прямыми, параллельными координатным осям, и идёт возврат к шагу~\ref{step:varnok1} Иначе рисуется изображение.
\end{enumerate}

Время работы алгоритма $O(CN)$, где $C$ -- количество пикселей в окне, а $N$ -- число полигонов на сцене. В худшем случае каждый пиксель будет рассматриваться как окно.

\subsection{Алгоритм Вейлера-Азертона}

Алгоритм Вейлера-Азертона является улучшенной версией алгоритма Варнока~\cite{cannon}. При разбиении окна прямые выбираются не параллельные координатным осям, а параллельные проекциям рёбер.

\subsection{Алгоритм, использующий Z-буфер}

Идея алгоритма состоит в том, чтобы для каждого пикселя дополнительно хранить ещё и координату $Z$ или глубину.~\cite{bands}. Алгоритм состоит из следующих шагов:

\begin{enumerate}[label=\arabic*.]
	\item Заполнение Z-буфера значением $-\infty$.
	\item При занесении очередного пикселя в буфер кадра значение его $Z$-координаты сравнивается с $Z$-координатой пикселя, который уже находится в буфере. Если $Z$-координата нового пикселя больше, чем координата старого, т.~е. он ближе к наблюдателю, то атрибуты нового пикселя и его $Z$-координата заносятся в буфер, если нет, то ни чего не делается. 
\end{enumerate}

Одним из главных минусов является высокое потребление памяти за счёт создания Z-буфера.

\subsection{Алгоритм, использующий список приоритетов}

Данный алгоритм иногда называют алгоритмом художника \cite{parshina}. Алгоритм состоит из следующих шагов:

\begin{enumerate}[label=\arabic*.]
	\item Cортировка полигонов по глубине или приоритету.
	\item Отрисовка полигонов, начиная с наиболее удалённых от точки наблюдения. 
\end{enumerate}

Более близкие к наблюдателю элементы будут <<затирать>> информацию о более далёких элементах в буфере кадра. Эффекты прозрачности можно включить в состав алгоритма путём не полной, а частичной корректировки содержимого буфера кадра с учётом атрибутов прозрачных элементов.

Проблема этого алгоритма заключается в том, что иногда приходится отдельно обрабатывать случаи частичного перекрытия интервалов глубины.

\subsection{Алгоритм обратной трассировки лучей}

Алгоритм состоит из следующих шагов~\cite{golovnin}:

\begin{enumerate}[label=\arabic*.]
	\item Создание лучей с началом в точке наблюдения, каждый луч проходит через один из пикселей.
	\item Определение пересечения лучей с объектами. Для упрощения используется сферическая или прямоугольная оболочка.
	\item Поиск ближайших точек пересечения. 
\end{enumerate}

\subsection{Сравнение алгоритмов}

В таблице \ref{tab:cut} представлено сравнение алгоритмов удаления невидимых линий и поверхностей и использованы следующие обозначения:

\begin{itemize}
	\item Р -- алгоритм Робертса;
	\item ПГ -- алгоритм плавающего горизонта;
	\item В -- алгоритм Варнока;
	\item ВА -- алгоритм Вейлера-Азертона;
	\item Z -- алгоритм, использующий Z-буфер;
	\item СП -- алгоритм, использующий список приоритетов;
	\item ТЛ -- алгоритм обратной трассировки лучей;
	\item О -- объектное пространство;
	\item И -- пространство изображения;
	\item А -- аналитически заданный объект;
	\item ВО -- выпуклые объекты;
	\item П -- полигональный объект;
	\item Л -- любой объект.
\end{itemize}

\begin{longtable}{|p{.3\textwidth - 2\tabcolsep}|p{.1\textwidth - 2\tabcolsep}|p{.1\textwidth - 2\tabcolsep}|p{.1\textwidth - 2\tabcolsep}|p{.1\textwidth - 2\tabcolsep}|p{.1\textwidth - 2\tabcolsep}|p{.1\textwidth - 2\tabcolsep}|p{.1\textwidth - 2\tabcolsep}|}
	\caption{\label{tab:cut}Сравнение алгоритмов генерации ландшафта} \\
	\hline
	\makecell{Критерий\\сравнения} & \makecell{Р} & \makecell{ПГ} & \makecell{В} & \makecell{ВА} & \makecell{Z} & \makecell{СП} & \makecell{ТЛ} \\  
	\hline
	\makecell{Пространство\\работы} & \makecell{О} & \makecell{И} & \makecell{И} & \makecell{О} & \makecell{И} & \makecell{О} & \makecell{И} \\  
	\hline
	\makecell{Сложность\\($N$ -- число\\полигонов,\\$C$ -- число пикселей)} & \makecell{$N^2$} & \makecell{$CN$} & \makecell{$CN$} & \makecell{$N^2$} & \makecell{$CN$} & \makecell{$CN$} & \makecell{$CN$} \\  
	\hline
	\makecell{Возможность\\вычислить\\интенсивность\\света} & \makecell{+} & \makecell{-} & \makecell{+} & \makecell{+} & \makecell{+} & \makecell{+} & \makecell{+} \\  
	\hline
	\makecell{Обрабатываемые\\объекты} & \makecell{ВО} & \makecell{А} & \makecell{Л} & \makecell{П} & \makecell{Л} & \makecell{П} & \makecell{Л} \\  
	\hline
\end{longtable}

В результате сравнения в качестве алгоритма удаления невидимых линий и поверхностей был выбран алгоритм, использующий Z-буфер, так как он подходит для решения поставленных задач.

\section{Анализ методов закраски}

Существуют следующие методы закраски~\cite{cannon}\cite{gaf}:

\begin{enumerate}[label=\arabic*.]
	\item Простая закраска.
	\item Закраска Гуро.
	\item Закраска Фонга.
\end{enumerate}

\subsection{Простая закраска}

В данном случае полигон закрашивается полностью одним цветом~\cite{cannon}. Предполагается, что и источник света находится в бесконечности. На изображении могут быть хорошо заметны резкие перепады интенсивности между различно закрашенными многоугольниками.

\subsection{Закраска Гуро}

Алгоритм состоит из следующих шагов~\cite{gaf}:

\begin{enumerate}[label=\arabic*.]
	\item вычисление интенсивности в вершинах как результат усреднения нормалей ко всем полигональным граням, которым принадлежит вершина;
	\item вычисление значение интенсивности в других пикселях при помощи билинейной интерполяции интенсивности. 
\end{enumerate}

У данного метода есть недостаток -- в результате его применения может появиться эффект полос Маха~\cite{cannon}.

\subsection{Закраска Фонга}

Алгоритм состоит из следующих шагов~\cite{gaf}:

\begin{enumerate}[label=\arabic*.]
	\item вычисление интенсивности в вершинах как результат усреднения нормалей ко всем полигональным граням, которым принадлежит вершина;
	\item вычисление значение интенсивности в других пикселях при помощи билинейной интерполяции векторов нормали. 
\end{enumerate}

Данный метод не устраняет эффект полос Маха, а в некоторых случаях он проявляется даже сильнее, чем для метода Гуро~\cite{cannon}.

\subsection{Сравнение алгоритмов}

Среди рассмотренных алгоритмов простая закраска наиболее быстрая, так как не требует никаких вычислений, и допустима, так как по условию единственный источник света находится на бесконечности, однако могут быть заметны резкие перепады интенсивности. Поэтому в качестве алгоритма закраски был выбран метод Гуро, так как интерполяция интенсивности выполняется быстрее чем интерполяция нормалей.

\section{Формализация задачи с учётом выбранных алгоритмов}

На рисунке~\ref{img:prog} представлена формализованная задача с учётом выбранных алгоритмов.

\FloatBarrier
\includeimage
{prog} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Формализованная задача с учётом выбранных алгоритмов} % Подпись рисунка
\FloatBarrier

\clearpage

\usection{Выводы}

В данном разделе была формализована поставленная задача, формализованы объекты сцены, а также произведён поиск и выбор подходящих алгоритмов для решения поставленной задачи. Для генерации ландшафта было принято решение использовать алгоритм, использующий кригинг. Для удаления невидимых линий был выбран алгоритм, использующий Z-буфер, а для закраски граней -- метод Гуро.