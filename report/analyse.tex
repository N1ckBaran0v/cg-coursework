\chapter{Аналитическая часть}

В данном разделе приведено описание объектов сцены, а также анализ существующих алгоритмов для решения поставленных задач, в результате которого выбраны наиболее подходящие из них.

\section{Формализация задачи}

На рисунке~\ref{img:without} представлена формализованная задача.

\FloatBarrier
\includeimage
{without} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Формализованная задача} % Подпись рисунка
\FloatBarrier

\section{Анализ объектов сцены}

Сцена состоит из следующих объектов:

\begin{itemize}
	\item источник света, расположенный на бесконечности -- задаётся 2 углами;
	\item камера -- задаётся положением в пространстве, фокусным расстоянием, дальностью видимости, а также 3 векторами, задающими систему координат камеры;
	\item ландшафт -- задаётся регулярной картой высот, так как параметрами генерации являются значения высот в точках и шаг задания точек, и множеством полигонов.
\end{itemize}

\section{Анализ алгоритмов генерации ландшафта}

Существуют следующие алгоритмы генерации ландшафта~\cite{landscapes}\cite{noises}\cite{nohabrinsource}\cite{usages}\cite{Voronezh}\cite{criging}:

\begin{itemize}
	\item шум Перлина;
	\item шум Симплекс;
	\item дробный шум Брауна;
	\item шум Value Noise;
	\item fault алгоритм;
	\item холмовой алгоритм;
	\item алгоритм diamond-square;
	\item алгоритм, использующий билинейную интерполяцию;
	\item алгоритм, использующий кригинг.
\end{itemize}

\subsection{Алгоритмы, основанные на шумовых функциях}

Алгоритмы, основанные на шумовых функциях, заполняют значения на карте высот результатами работы шумовых функций~\cite{noises}. Однако шумовые функции никак не учитывают заранее заданные на ландшафте значения высот, поэтому не подходят для генерации ландшафта.

\subsection{Fault алгоритм}

Fault алгоритм заключается в выполнении следующих шагов в несколько итераций~\cite{nohabrinsource}:

\begin{enumerate}
	\item разделение плоскости прямой на 2 части;
	\item повышение значений высот в одной части и понижение в другой.
\end{enumerate}

Данный алгоритм не подходит для генерации ландшафта с заранее заданными значениями высот.

\subsection{Холмовой алгоритм}

Холмовой алгоритм заключается в создании холмов на определённой области~\cite{usages}. При этом он не предусматривает наличие заранее заданных значений высот, из-за чего не подходит для генерации ландшафта.

\subsection{Алгоритм diamond-square}

Алгоритм diamond-square представляет собой расширенную версию алгоритма midpoint displacement, заключающуюся в использовании двумерной плоскости и наличии 2 этапов~\cite{ds}:

\begin{enumerate}
	\item этап <<square>> -- определение центральных точек для квадратов и присваивание им среднего значения из вершин со случайным смещением;
	\item этап <<diamond>> -- определение центральных точек для ромбов и присваивание им среднего значения из вершин со случайным смещением. Крайние случаи необходимо рассматривать отдельно, так как часть вершин может отсутствовать.
\end{enumerate}

На выходе у него получается регулярная карта высот. Таким образом, выходит, что вся плоскость покрыта квадратами. Порядок генерации точек можно увидеть на рисунке~\ref{img:ds}. 

\FloatBarrier
\includeimage
{ds} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{0.5\textwidth} % Ширина рисунка
{Порядок генерации высот в алгоритме diamond-square~\cite{images}} % Подпись рисунка
\FloatBarrier

Данный алгоритм хорошо подходит для генерации гор~\cite{landscapes}. При этом у данного алгоритма есть сложности с генерацией значений на границах квадрата, так как на шаге square не хватает одной точки. Также сторона квадрата должна иметь размер $2^n+1$.   
 
\subsection{Алгоритм, использующий билинейную интерполяцию}
 
Алгоритм заключается в заполнении значений на карте высот результатом работы функции билинейной интерполяции $f(x, y)$~\cite{Voronezh}. Значение $f(x, y)$ рассчитывается по формуле~\ref{eq:fxy}, где $f_1(x,y)$ рассчитывается по формуле~\ref{eq:f1}, а $f_2(x,y)$ -- по формуле~\ref{eq:f2}, причём точка $(x, y)$ находится внутри прямоугольника с вершинами в точках $(x_1, y_1)$, $(x_2, y_1)$, $(x_1, y_2)$, $(x_2, y_2)$, значения в которых равны $h_{11}$, $h_{21}$, $h_{12}$ и $h_{22}$ соответственно. 

\begin{equation}
	\label{eq:fxy}
	f(x,y)=f_1(x,y)+f_2(x,y)
\end{equation}

\begin{equation}
	\label{eq:f1}
	f_1(x,y)=\frac{h_{11}\cdot(x_2-x)\cdot(y_2-y)}{(x_2-x_1)\cdot(y_2-y_1)}+\frac{h_{21}\cdot(x-x_1)\cdot(y_2-y)}{(x_2-x_1)\cdot(y_2-y_1)}
\end{equation}

\begin{equation}
	\label{eq:f2}
	f_2(x,y)=\frac{h_{12}\cdot(x_2-x)\cdot(y-y_1)}{(x_2-x_1)\cdot(y_2-y_1)}+\frac{h_{22}\cdot(x-x_1)\cdot(y-y_1)}{(x_2-x_1)\cdot(y_2-y_1)}
\end{equation}

\subsection{Алгоритм, использующий кригинг}

Цель кригинга – найти такую модель данных, среднее квадратичное значение ошибки которой будет минимальным~\cite{criging}. Оценка значения в точке~$x_0$~$z_k(x_0)$ рассчитывается по формуле~\ref{eq:zx}. В ней $n$ -- число точек, от которых зависит значение в точке~$x_0$, $z(x_i)$ -- значения в этих точках, а $\lambda_i$ -- вес значения.

\begin{equation}
	\label{eq:zx}
	z_k(x_0) = \sum_{i=1}^{n}\lambda_i \cdot z(x_i)
\end{equation}

Алгоритм состоит из следующих шагов:

\begin{enumerate}
	\item составление ковариационной матрицы~$C$ расстояний между всеми известными точками. Значение в строке~$i$ столбца~$j$~$C_{ij}$ рассчитывается по формуле~\ref{eq:cov}. В ней $h$ -- расстояние между точками $i$ и $j$, $a$ -- радиус вариограммы;
	
\begin{equation}
	\label{eq:cov}
	C_{ij} = Cov(h) = 1 - \exp^{-\frac{h}{a}}
\end{equation}
	
	\item решение системы уравнений~\ref{eq:linal} для каждой точки~$x_0$, после чего вычисление значения по формуле~\ref{eq:zx}.
	
\begin{equation}
	\label{eq:linal}
	\begin{cases}
		\lambda_1 \cdot C_{11} + \lambda_2 \cdot C_{12} + \ldots + \lambda_n \cdot C_{1n} - C_{10} = 0\\
		\lambda_1 \cdot C_{21} + \lambda_2 \cdot C_{22} + \ldots + \lambda_n \cdot C_{2n} - C_{20} = 0\\
		\ldots\\
		\lambda_1 \cdot C_{n1} + \lambda_2 \cdot C_{n2} + \ldots + \lambda_n \cdot C_{nn} - C_{n0} = 0\\
	\end{cases}
\end{equation}

\end{enumerate}

\subsection{Сравнение алгоритмов}

Из всех рассмотренных алгоритмов только алгоритм diamond-square, алгоритм, использующий билинейную интерполяцию, а также алгорит, использующий кригинг, подходят для генерации ландшафта с изначально заданными точками. В таблице~\ref{tab:gen} представлено сравнение всех подходящих алгоритмов генерации ландшафта.

\begin{longtable}{|p{.25\textwidth - 2\tabcolsep}|p{.25\textwidth - 2\tabcolsep}|p{.25\textwidth - 2\tabcolsep}|p{.25\textwidth - 2\tabcolsep}|}
	\caption{\label{tab:gen}Сравнение алгоритмов генерации ландшафта} \\
	\hline
	\makecell{Критерий\\сравнения} & \makecell{Алгоритм\\diamond-square} & \makecell{Алгоритм,\\использующий\\билинейную\\интерполяцию} & \makecell{Алгоритм,\\использующий\\кригинг}\\  
	\hline
	\makecell{Нужен\\генератор\\случайных\\чисел} & \makecell{Да} & \makecell{Нет} & \makecell{Нет} \\  
	\hline
	\makecell{Проблемы\\с генерацией\\значений\\на границах} & \makecell{Да} & \makecell{Нет} & \makecell{Нет} \\  
	\hline
	\makecell{Значение\\зависит от\\всех точек} & \makecell{Нет} \makecell{Нет} & \makecell{Да} \\  
	\hline
\end{longtable}

В результате сравнения был выбран алгоритм, использующий кригинг, так как ему не нужны дополнительные параметры генерации, а также при генерации значения в одной точке он может учесть все заданные значения высот.

\section{Анализ алгоритмов удаления невидимых линий и поверхностей}

Для получения изображения необходимо решить задачу удаления невидимых линий и поверхностей, а также выбрать метод закраски полигонов. Существуют следующие алгоритмы удаления невидимых линий и поверхностей~\cite{parshina}\cite{golovnin}\cite{cannon}:

\begin{itemize}
	\item алгоритм Робертса;
	\item алгоритм плавающего горизонта;
	\item алгоритм Варнока;
	\item алгоритм Вейлера-Азертона;
	\item алгоритм, использующий Z-буфер;
	\item алгоритм, использующий список приоритетов;
	\item алгоритм обратной трассировки лучей.
\end{itemize}

\subsection{Алгоритм Робертса}

Данный алгоритм работает в объектном пространстве~\cite{lost}. Алгоритм состоит из следующих шагов: 

\begin{enumerate}
	\item удаление нелицевых граней, экранируемых самим телом;
	\item удаление рёбер, экранируемых другими телами;
	\item вычисление новых рёбер, полученных при <<протыкании>> друг друга.
\end{enumerate}

Время работы алгоритма $O(N^2)$, где $N$ -- число рёбер.

Ландшафт не является выпуклым телом, поэтому для данного алгоритма его придётся изначально разделить на выпуклые тела.

\subsection{Алгоритм плавающего горизонта}

Алгоритм плавающего горизонта используется при представлении поверхности в виде функции $F(x,y,z)=0$~\cite{golovnin}. Алгоритм состоит из следующих шагов:

\begin{enumerate}
	\item пересечение поверхности параллельными плоскостями с постоянной координатой z (ось y направлена вверх);
	\item построение кривой для каждой такой плоскости, начиная с ближайшей, лежащей на ней. Если же при заданном значении x значение y больше других найденных, то кривая видима в этой точке.
\end{enumerate}

\subsection{Алгоритм Варнока}

Алгоритм Варнока состоит из следующих шагов~\cite{cannon}:

\begin{enumerate}
	\item \label{step:varnok1}рассмотрение окна и решение вопроса о том, пусто ли оно
	или является его содержимое достаточно простым для визуализации;
	\item если это не так, то окно разбивается на фрагменты прямыми, параллельными координатным осям, и идёт возврат к шагу~1. Иначе рисуется изображение.
\end{enumerate}

Время работы алгоритма $O(CN)$, где $C$ -- количество пикселей в окне, а $N$ -- число полигонов на сцене. В худшем случае каждый пиксель будет рассматриваться как окно.

\subsection{Алгоритм Вейлера-Азертона}

Алгоритм Вейлера-Азертона является улучшенной версией алгоритма Варнока~\cite{cannon}. При разбиении окна прямые выбираются не параллельные координатным осям, а параллельные проекциям рёбер.

\subsection{Алгоритм, использующий Z-буфер}

Идея алгоритма состоит в том, чтобы для каждого пикселя дополнительно хранить ещё и координату $Z$ или глубину~\cite{bands}. Алгоритм состоит из следующих шагов:

\begin{enumerate}
	\item заполнение Z-буфера значением $-\infty$;
	\item при занесении очередного пикселя в буфер кадра значение его $Z$-координаты сравнивается с $Z$-координатой пикселя, который уже находится в буфере. Если $Z$-координата нового пикселя больше, чем координата старого, т.~е. он ближе к наблюдателю, то атрибуты нового пикселя и его $Z$-координата заносятся в буфер, если нет, то ни чего не делается. 
\end{enumerate}

Одним из главных минусов является высокое потребление памяти за счёт создания Z-буфера.

\subsection{Алгоритм, использующий список приоритетов}

Данный алгоритм иногда называют алгоритмом художника~\cite{parshina}. Алгоритм состоит из следующих шагов:

\begin{enumerate}
	\item сортировка полигонов по глубине или приоритету;
	\item отрисовка полигонов, начиная с наиболее удалённых от точки наблюдения. 
\end{enumerate}

Более близкие к наблюдателю элементы будут <<затирать>> информацию о более далёких элементах в буфере кадра. Эффекты прозрачности можно включить в состав алгоритма путём не полной, а частичной корректировки содержимого буфера кадра с учётом атрибутов прозрачных элементов.

Проблема этого алгоритма заключается в том, что иногда приходится отдельно обрабатывать случаи частичного перекрытия интервалов глубины.

\subsection{Алгоритм обратной трассировки лучей}

Алгоритм состоит из следующих шагов~\cite{golovnin}:

\begin{enumerate}[label=\arabic*.]
	\item создание лучей с началом в точке наблюдения, каждый луч проходит через один из пикселей;
	\item определение пересечения лучей с объектами. Для упрощения используется сферическая или прямоугольная оболочка;
	\item поиск ближайших точек пересечения. 
\end{enumerate}

\subsection{Сравнение алгоритмов}

В таблице \ref{tab:cut} представлено сравнение алгоритмов удаления невидимых линий и поверхностей и использованы следующие обозначения:

\begin{itemize}
	\item Р -- алгоритм Робертса;
	\item ПГ -- алгоритм плавающего горизонта;
	\item В -- алгоритм Варнока;
	\item ВА -- алгоритм Вейлера-Азертона;
	\item Z -- алгоритм, использующий Z-буфер;
	\item СП -- алгоритм, использующий список приоритетов;
	\item ТЛ -- алгоритм обратной трассировки лучей;
	\item О -- объектное пространство;
	\item И -- пространство изображения;
	\item А -- аналитически заданный объект;
	\item ВО -- выпуклые объекты;
	\item П -- полигональный объект;
	\item Л -- любой объект.
\end{itemize}

\begin{longtable}{|p{.3\textwidth - 2\tabcolsep}|p{.1\textwidth - 2\tabcolsep}|p{.1\textwidth - 2\tabcolsep}|p{.1\textwidth - 2\tabcolsep}|p{.1\textwidth - 2\tabcolsep}|p{.1\textwidth - 2\tabcolsep}|p{.1\textwidth - 2\tabcolsep}|p{.1\textwidth - 2\tabcolsep}|}
	\caption{\label{tab:cut}Сравнение алгоритмов генерации ландшафта} \\
	\hline
	\makecell{Критерий\\сравнения} & \makecell{Р} & \makecell{ПГ} & \makecell{В} & \makecell{ВА} & \makecell{Z} & \makecell{СП} & \makecell{ТЛ} \\  
	\hline
	\makecell{Пространство\\работы} & \makecell{О} & \makecell{И} & \makecell{И} & \makecell{О} & \makecell{И} & \makecell{О} & \makecell{И} \\  
	\hline
	\makecell{Сложность\\($N$ -- число\\полигонов,\\$C$ -- число пикселей)} & \makecell{$N^2$} & \makecell{$CN$} & \makecell{$CN$} & \makecell{$N^2$} & \makecell{$CN$} & \makecell{$CN$} & \makecell{$CN$} \\  
	\hline
	\makecell{Возможность\\вычислить\\интенсивность\\света} & \makecell{+} & \makecell{-} & \makecell{+} & \makecell{+} & \makecell{+} & \makecell{+} & \makecell{+} \\  
	\hline
	\makecell{Обрабатываемые\\объекты} & \makecell{ВО} & \makecell{А} & \makecell{Л} & \makecell{П} & \makecell{Л} & \makecell{П} & \makecell{Л} \\  
	\hline
\end{longtable}

В результате сравнения в качестве алгоритма удаления невидимых линий и поверхностей был выбран алгоритм, использующий Z-буфер, так как он подходит для решения поставленных задач.

\section{Анализ методов закраски}

Существуют следующие методы закраски~\cite{cannon}\cite{gaf}:

\begin{enumerate}[label=\arabic*.]
	\item закраска Гуро;
	\item закраска Фонга.
\end{enumerate}

\subsection{Закраска Гуро}

Алгоритм состоит из следующих шагов~\cite{gaf}:

\begin{enumerate}[label=\arabic*.]
	\item вычисление интенсивности в вершинах как результат усреднения нормалей ко всем полигональным граням, которым принадлежит вершина;
	\item вычисление значение интенсивности в других пикселях при помощи интерполяции интенсивности. 
\end{enumerate}

У данного метода есть недостаток -- в результате его применения может появиться эффект полос Маха~\cite{cannon}.

\subsection{Закраска Фонга}

Алгоритм состоит из следующих шагов~\cite{gaf}:

\begin{enumerate}[label=\arabic*.]
	\item вычисление интенсивности в вершинах как результат усреднения нормалей ко всем полигональным граням, которым принадлежит вершина;
	\item вычисление значение интенсивности в других пикселях при помощи интерполяции векторов нормали. 
\end{enumerate}

Данный метод не устраняет эффект полос Маха, а в некоторых случаях он проявляется даже сильнее, чем для метода Гуро~\cite{cannon}.

\subsection{Сравнение алгоритмов}

В качестве алгоритма закраски был выбран метод Гуро, так как интерполяция интенсивности выполняется быстрее интерполяции нормалей.

\section{Формализация задачи с учётом выбранных алгоритмов}

На рисунке~\ref{img:prog} представлена формализованная задача с учётом выбранных алгоритмов.

\FloatBarrier
\includeimage
{prog} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Формализованная задача с учётом выбранных алгоритмов} % Подпись рисунка
\FloatBarrier

\usection{Выводы}

В данном разделе была формализована поставленная задача, формализованы объекты сцены, а также произведён поиск и выбор подходящих алгоритмов для решения поставленной задачи. Для генерации ландшафта было принято решение использовать алгоритм, использующий кригинг. Для удаления невидимых линий был выбран алгоритм, использующий Z-буфер, а для закраски граней -- метод Гуро.